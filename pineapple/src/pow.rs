/*
Research done by matching symbols from version 0.7.2.26 for iOS with latest linux version (122501009)
Frida used for hooking and logging

sp::hashcash_key - Only first 20 bytes are used
A3 AD B1 31 AB 58 45 07 CB 7A 68 AE E1 A5 F9 0B 4D 7F 07 11 00 00 00 00 00 00 00 00 00 00 00 00

// `suffix` is a pointer to the mutable protobuf array (output)
// `prefix` and `prefix_len` come from the AP challenge
// `length` comes from the AP challenge, specifies how many trailing zero bits to target
// `target` is XOR'd with the suffix before checking the trailing zeroes
ApConnectionImpl::powSolveHashcash(this, suffix, prefix, prefix_len, length, target)
    // SHA1HMAC of ClientHello and APResponse using hashcash key
    context_bytes = SHA1HMAC(hashcash_key, 20, accumulator);
    context = BigEndian::read64(context_bytes);

    memset(suffix, 0, 16);
    for (i = 0; ; i++, context++) {
        BigEndian::write64(&suffix[0x0], context);
        BigEndian::write64(&suffix[0x8], i);
        sha_ctx = SHA1::new()
        sha_ctx.update(prefix, prefix_len);
        sha_ctx.update(suffix, 16);
        digest = sha_ctx.finish();

        // Interpret last 4 bytes of digest as uint32, then AND with `target` LSB's set to 1 and compare with zero
        if ( ( (BigEndian::read32(&digest[16]) ^ target) & (1 << length) -1) == 0 ) {
            break;
        }
    }
*/

use std::io::{Error, ErrorKind};

use byteorder::{BigEndian, ByteOrder};
use hmac::{Hmac, Mac};
use lazy_static::lazy_static;
use pineapple_proto::keyexchange_old::PoWHashCashChallenge;
use sha1::{Digest, Sha1};

type HmacSha1 = Hmac<Sha1>;

lazy_static! {
    static ref HASHCASH_KEY: Vec<u8> = vec![
        0xA3, 0xAD, 0xB1, 0x31, 0xAB, 0x58, 0x45, 0x07, 0xCB, 0x7A, 0x68, 0xAE, 0xE1, 0xA5, 0xF9, 0x0B, 0x4D, 0x7F,
        0x07, 0x11,
    ];
}

pub fn solve_hashcash(accumulator: &[u8], challenge: &PoWHashCashChallenge) -> Result<Vec<u8>, Error> {
    let mut hmac_ctx = HmacSha1::new_from_slice(&HASHCASH_KEY)
        .map_err(|_| Error::new(ErrorKind::Other, "Failed to create HMAC instance"))?;
    hmac_ctx.update(accumulator);
    let context_bytes = hmac_ctx.finalize().into_bytes();
    let mut context = BigEndian::read_u64(&context_bytes);

    let prefix = challenge.prefix();
    let length = challenge.length() as u32;
    let target = challenge.target() as u32;
    let mut suffix = vec![0; 16];

    let mut idx = 0;
    loop {
        BigEndian::write_u64(&mut suffix[0x0..0x08], context);
        BigEndian::write_u64(&mut suffix[0x8..0x10], idx);
        let mut sha_ctx = Sha1::new();
        sha_ctx.update(prefix);
        sha_ctx.update(&suffix);
        let digest = sha_ctx.finalize();

        if (BigEndian::read_u32(&digest[16..]) ^ target).trailing_zeros() > length {
            break;
        }

        idx += 1;
        context += 1;
    }

    Ok(suffix)
}

#[cfg(test)]
mod tests {
    use pineapple_proto::keyexchange_old::APResponseMessage;
    use protobuf::Message;

    use crate::pow::solve_hashcash;

    #[test]
    fn test_hashcash() {
        let client_hello: Vec<u8> = vec![
            0x00, 0x04, 0x00, 0x00, 0x01, 0x67, 0x52, 0x0e, 0x50, 0x00, 0xa0, 0x01, 0x00, 0xf0, 0x01, 0x08, 0xc0, 0x02,
            0x91, 0xef, 0xb4, 0x3a, 0xa0, 0x01, 0x00, 0xf0, 0x01, 0x00, 0xc0, 0x02, 0x00, 0x92, 0x03, 0x67, 0x52, 0x65,
            0x52, 0x60, 0x87, 0x0b, 0x85, 0x7e, 0xd1, 0xa3, 0x6d, 0x08, 0x56, 0x4f, 0xec, 0x32, 0xf5, 0x24, 0x67, 0xb5,
            0x6a, 0x87, 0x0a, 0x9b, 0x5f, 0x8b, 0x4b, 0x64, 0x0b, 0xc3, 0x36, 0xaf, 0x1b, 0x67, 0x39, 0x1d, 0x76, 0xc4,
            0x8b, 0x0b, 0x24, 0xf2, 0xdd, 0x64, 0x14, 0x28, 0x5c, 0xb2, 0x15, 0x89, 0xa5, 0x06, 0x7c, 0x6d, 0xf8, 0xb2,
            0x5b, 0x9b, 0xd7, 0xa2, 0x6f, 0xa3, 0x4f, 0x65, 0x22, 0x83, 0x3a, 0xd1, 0x2a, 0x15, 0xf8, 0xef, 0xd9, 0x2f,
            0xf0, 0x39, 0xb5, 0x11, 0x6e, 0x0a, 0x67, 0x61, 0x99, 0x2f, 0x6b, 0xb6, 0x9c, 0xf2, 0x50, 0x75, 0x87, 0xeb,
            0x09, 0x83, 0xb2, 0x2a, 0xf9, 0x11, 0x21, 0x4a, 0xa0, 0x01, 0x01, 0xe2, 0x03, 0x10, 0x79, 0xd1, 0x66, 0x76,
            0x25, 0x68, 0x66, 0x9d, 0x53, 0x3b, 0xac, 0x38, 0xde, 0x66, 0x1e, 0x44, 0xb2, 0x04, 0xbc, 0x01, 0xa8, 0x3d,
            0x8f, 0x6b, 0x80, 0xe8, 0xbf, 0x50, 0x5c, 0xb7, 0x64, 0x85, 0xca, 0xb8, 0xce, 0xf2, 0x6c, 0x0a, 0xdd, 0x9b,
            0x03, 0xcf, 0x4f, 0xa8, 0x6c, 0x6c, 0x30, 0x2d, 0x27, 0x38, 0x3d, 0xd0, 0x6e, 0xb4, 0xff, 0x22, 0xda, 0xa8,
            0xb7, 0xa5, 0x2c, 0x77, 0xce, 0xdd, 0x3e, 0xf2, 0x3f, 0x05, 0x79, 0xb4, 0xcb, 0x1b, 0x4d, 0x7d, 0x41, 0x48,
            0x03, 0x74, 0x6a, 0x0a, 0x2f, 0x7e, 0x60, 0x57, 0x1a, 0x09, 0x0b, 0xc4, 0xdf, 0xf3, 0x04, 0x8e, 0x5e, 0x5c,
            0xa1, 0xfa, 0x9c, 0x15, 0x3c, 0x0e, 0x3d, 0x66, 0xba, 0x63, 0x2d, 0x5e, 0xe8, 0x94, 0xf2, 0x8e, 0x0e, 0x10,
            0x9e, 0x7f, 0x4c, 0xee, 0x27, 0x7b, 0x9d, 0x53, 0x07, 0x15, 0x47, 0xe5, 0xe0, 0x81, 0x00, 0xdb, 0x90, 0xd8,
            0x59, 0xdc, 0xa7, 0xff, 0x2f, 0x4e, 0x9c, 0x91, 0x08, 0xa5, 0x66, 0xb1, 0xbc, 0x51, 0x2b, 0xd5, 0x63, 0x6a,
            0x9c, 0x03, 0x1f, 0x6e, 0xb8, 0x4f, 0x1b, 0xa4, 0x86, 0xb1, 0x7d, 0x5e, 0x96, 0xf9, 0x2f, 0x60, 0x7a, 0x68,
            0x8d, 0x10, 0xcf, 0x0b, 0x0f, 0x44, 0xcc, 0x78, 0x29, 0x8b, 0x7b, 0x45, 0xdb, 0xf6, 0x08, 0x24, 0x82, 0x48,
            0x9e, 0x5f, 0x57, 0xdb, 0x1c, 0x0b, 0xe0, 0x01, 0xb8, 0xb3, 0x0e, 0x6e, 0xa1, 0x35, 0x66, 0xdb, 0x86, 0x57,
            0xb0, 0x35, 0xa1, 0x83, 0x8c, 0xed, 0x82, 0x05, 0x08, 0x08, 0x01, 0x1a, 0x00, 0x2a, 0x02, 0x08, 0x00,
        ];
        let ap_response: Vec<u8> = vec![
            0x00, 0x00, 0x02, 0x71, 0x52, 0xea, 0x04, 0x52, 0xec, 0x02, 0x52, 0xe9, 0x02, 0x52, 0x60, 0x1a, 0x69, 0xef,
            0xa7, 0x3d, 0x4f, 0xef, 0xf4, 0x5a, 0xeb, 0x97, 0x9e, 0xb4, 0x0e, 0x56, 0x4c, 0x0a, 0x4d, 0xe7, 0x8c, 0xcf,
            0x09, 0x47, 0x56, 0xf6, 0xa7, 0x18, 0x46, 0x69, 0x56, 0xc5, 0x7a, 0x0d, 0x17, 0x1a, 0xbd, 0x53, 0x59, 0x7a,
            0x33, 0xcf, 0xc7, 0x07, 0x74, 0x5b, 0x01, 0x3f, 0xcc, 0xfa, 0x61, 0x00, 0x70, 0x33, 0xab, 0xb2, 0x11, 0x81,
            0x25, 0x77, 0xf4, 0x3f, 0xa9, 0x29, 0xa1, 0x5b, 0x9c, 0x4c, 0x12, 0xf7, 0x34, 0xdc, 0x0c, 0xa0, 0x81, 0xc2,
            0xa3, 0x74, 0x90, 0x11, 0xdc, 0xcf, 0x81, 0x4e, 0x63, 0x21, 0x18, 0x29, 0x8a, 0xaf, 0x22, 0xad, 0xc6, 0x82,
            0xd1, 0x82, 0xb0, 0xa0, 0x01, 0x00, 0xf2, 0x01, 0x80, 0x02, 0x90, 0x33, 0xdf, 0x67, 0x37, 0x19, 0x75, 0x52,
            0xd5, 0x13, 0x8f, 0xc3, 0xa4, 0x3e, 0xc5, 0xb6, 0x65, 0xe8, 0xbe, 0x27, 0x27, 0x16, 0x4b, 0x8f, 0x20, 0xb8,
            0x0e, 0x6b, 0xb1, 0x45, 0x52, 0x28, 0xc6, 0xb0, 0x33, 0x65, 0x1b, 0x03, 0x46, 0xc5, 0x0e, 0x90, 0x94, 0x1a,
            0xaa, 0xac, 0x79, 0x86, 0x9e, 0xc5, 0x44, 0x8d, 0x40, 0xda, 0x1f, 0x73, 0xf1, 0xd7, 0xbb, 0x08, 0x68, 0xdd,
            0x63, 0x28, 0x07, 0x3c, 0x81, 0x39, 0xeb, 0xb1, 0xa4, 0x6b, 0xdb, 0x5d, 0xd0, 0xdd, 0xe3, 0x1d, 0x5e, 0xf4,
            0xcc, 0xad, 0x6c, 0x25, 0x12, 0x71, 0x21, 0xd5, 0xd9, 0xbe, 0xec, 0x45, 0x78, 0xff, 0x3b, 0x07, 0x66, 0xa0,
            0x4f, 0xa6, 0xd8, 0x52, 0xb9, 0x19, 0xbd, 0x76, 0xb3, 0x9f, 0xbd, 0xff, 0x6f, 0x35, 0x9a, 0x09, 0x94, 0xce,
            0xb4, 0x85, 0x05, 0x82, 0xb3, 0x56, 0xd0, 0x95, 0x47, 0x04, 0xc2, 0xba, 0x69, 0x52, 0x86, 0xd2, 0xec, 0xf3,
            0xc1, 0xcd, 0x0e, 0xf0, 0x29, 0x4e, 0x33, 0x78, 0x78, 0xaa, 0xc2, 0xb0, 0xd5, 0xe9, 0x01, 0xf5, 0xfb, 0x23,
            0xad, 0x57, 0xba, 0x04, 0x71, 0xbd, 0xcf, 0xcd, 0xf1, 0x09, 0x93, 0x5c, 0xb8, 0xb7, 0x47, 0x41, 0x6a, 0x40,
            0xa8, 0x3f, 0xaa, 0x40, 0xcc, 0x33, 0x3a, 0xfe, 0xe2, 0xbc, 0xe1, 0xeb, 0x97, 0xd5, 0xa8, 0xfa, 0xbc, 0xb4,
            0xb0, 0x30, 0xb1, 0x71, 0xe6, 0x60, 0xee, 0xfe, 0x6d, 0x71, 0xd3, 0xa2, 0x9f, 0x09, 0x05, 0x7d, 0xaf, 0x04,
            0xb5, 0xb2, 0xca, 0xac, 0x2a, 0x8a, 0xe1, 0x74, 0xb1, 0xc7, 0x1b, 0xf7, 0x5a, 0xe4, 0x74, 0x0d, 0x77, 0x7c,
            0x13, 0x4e, 0x7a, 0xbe, 0x23, 0xfc, 0xf5, 0xe5, 0xf2, 0xba, 0x3b, 0x8e, 0x18, 0x9c, 0x84, 0x2c, 0x0a, 0xa7,
            0x60, 0xcc, 0xeb, 0x8b, 0xc8, 0x68, 0xc8, 0x77, 0x39, 0x1f, 0x68, 0x7d, 0xc4, 0xcd, 0xa2, 0x01, 0x14, 0x52,
            0x12, 0x52, 0x10, 0xab, 0xef, 0xe8, 0x61, 0xef, 0x68, 0xaa, 0xe0, 0x37, 0xa1, 0x80, 0x11, 0x97, 0x4d, 0x27,
            0x5a, 0xf2, 0x01, 0x1c, 0x52, 0x1a, 0x52, 0x10, 0xcd, 0x16, 0xc3, 0xe8, 0x38, 0x57, 0x84, 0x7f, 0x4e, 0xcc,
            0x70, 0x53, 0x82, 0x7e, 0x81, 0x3f, 0xa0, 0x01, 0x0f, 0xf0, 0x01, 0xc5, 0xd7, 0x01, 0xc2, 0x02, 0x02, 0x52,
            0x00, 0x92, 0x03, 0x10, 0xcd, 0x16, 0xc3, 0xe8, 0x38, 0x57, 0x84, 0x7f, 0x4e, 0xcc, 0x70, 0x53, 0x82, 0x7e,
            0x81, 0x3f, 0xe2, 0x03, 0xa9, 0x01, 0x5f, 0xb1, 0xb9, 0xde, 0x00, 0x85, 0x4e, 0x53, 0x08, 0xcd, 0xd5, 0x47,
            0x92, 0x40, 0xf2, 0x82, 0x28, 0x53, 0x71, 0x90, 0xfd, 0x51, 0xc7, 0x9e, 0xd2, 0xd9, 0x36, 0x1f, 0x00, 0x90,
            0x55, 0x60, 0x42, 0x0e, 0x3e, 0x42, 0x94, 0x8d, 0x95, 0x9c, 0x5a, 0x6a, 0xe3, 0xec, 0xaa, 0xd5, 0x6e, 0xd3,
            0x28, 0xdf, 0x63, 0x25, 0x31, 0x2b, 0xc3, 0x03, 0x04, 0xf9, 0x22, 0x04, 0x8a, 0x77, 0x64, 0xcc, 0x86, 0xa3,
            0x0e, 0x1a, 0x30, 0xa3, 0xb6, 0x8a, 0x0e, 0x99, 0x76, 0xb8, 0x6e, 0xe5, 0x8b, 0x96, 0xc4, 0xef, 0xbb, 0xf5,
            0x1a, 0x7e, 0xf8, 0x1e, 0x78, 0x1b, 0x22, 0x02, 0x92, 0x87, 0xce, 0x18, 0x2a, 0xdc, 0x32, 0x5a, 0x7f, 0xe8,
            0xe4, 0x8d, 0x81, 0x5a, 0x46, 0xef, 0x3f, 0xd1, 0x85, 0x04, 0xc0, 0x40, 0xf9, 0xda, 0xbf, 0xf2, 0xf8, 0x37,
            0x0d, 0x1b, 0x39, 0x9f, 0xa2, 0x07, 0xb8, 0xcc, 0xe3, 0xea, 0x26, 0x62, 0xd3, 0x0a, 0xf0, 0x54, 0x64, 0x36,
            0x44, 0xa4, 0x07, 0xc9, 0xa8, 0xc8, 0x0a, 0xa1, 0xa2, 0xc9, 0x93, 0x9b, 0x00, 0xa0, 0xb6, 0x39, 0x40, 0x58,
            0x40, 0xf8, 0x24, 0x23, 0xe2, 0x4a, 0x85, 0xb5, 0x54, 0x75, 0x0a, 0xb8, 0xab,
        ];
        let suffix =
            vec![0xed, 0x56, 0x9b, 0xf4, 0xbb, 0x14, 0xe9, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x2e];

        assert_eq!(client_hello[0..2], [0x00, 0x04]);
        let client_hello_length = u32::from_be_bytes(client_hello[2..6].try_into().unwrap());
        assert_eq!(client_hello_length as usize, client_hello.len());
        let ap_response_length = u32::from_be_bytes(ap_response[0..4].try_into().unwrap());
        assert_eq!(ap_response_length as usize, ap_response.len());

        let ap_response_msg =
            APResponseMessage::parse_from_bytes(&ap_response[4..]).expect("Failed to parse APResponse");
        let hashcash_challenge =
            ap_response_msg.challenge.pow_challenge.hash_cash.as_ref().expect("Expected POW challenge");
        let accumuluator: Vec<u8> = [client_hello, ap_response].into_iter().flatten().collect();

        assert_eq!(
            suffix,
            solve_hashcash(&accumuluator, hashcash_challenge).expect("Failed to solve challenge")
        )
    }
}
